CASCADING BANDITS WITH LinUCB - PSEUDOCODE

Overview

This system implements a personalized recommendation engine using Cascading Bandits with Linear Upper Confidence Bound (LinUCB) algorithm.
INITIALIZATION

Example
DEFINE:
  - Feature dimension d = 6
  - Exploration parameter Î± = 1.0
  - For each product i:
      A_i = I_d (dÃ—d identity matrix)
      b_i = 0_d (d-dimensional zero vector)
PART 1: PREDICTION PHASE (RE-RANKING)

Example
FUNCTION ReRankProducts():
    
    INPUT:
        - User features: [offline_transactions, offline_atv, online_transactions, online_atv]
        - Product features: [global_popularity, co_occurrence]
        - Current matrices: A_i, b_i for each product
        - Existing rankings for each user
    
    FOR each user u:
        FOR each product i in user's catalog:
            
            // Step 1: Combine features into context vector
            x_ui = CONCATENATE(user_features[u], product_features[i])
            // x_ui = [u_offline_trans, u_offline_atv, u_online_trans, 
            //         u_online_atv, i_popularity, i_co_occurrence]
            
            // Step 2: Calculate estimated reward (exploitation)
            Î¸_i = A_i^(-1) Ã— b_i
            raw_score_ui = Î¸_i^T Ã— x_ui
            
            // Step 3: Calculate uncertainty (exploration)
            uncertainty_ui = Î± Ã— sqrt(x_ui^T Ã— A_i^(-1) Ã— x_ui)
            
            // Step 4: Calculate UCB score
            ucb_score_ui = raw_score_ui + uncertainty_ui
            
        END FOR
        
        // Step 5: Rank products by UCB score (descending)
        new_ranking[u] = SORT products by ucb_score_ui DESC
        
    END FOR
    
    // Step 6: Persist new rankings
    UPDATE user_product_rankings_table WITH new_ranking
    
    RETURN new_ranking

END FUNCTION
PART 2: UPDATE PHASE (LEARNING FROM CLICKS)

Example
FUNCTION LearnFromClicks():
    
    INPUT:
        - Click events: (user_id, clicked_product_id)
        - Current rankings for each user
        - User features and product features
        - Current matrices: A_i, b_i for each product
    
    // Initialize update accumulators
    A_updates = {} // Dictionary: product_id â†’ list of A matrices
    b_updates = {} // Dictionary: product_id â†’ list of b vectors
    
    FOR each click event (u, clicked_product):
        
        // Step 1: Find position of clicked product
        click_position = FIND_POSITION(clicked_product IN ranking[u])
        
        // Step 2: Get cascade (all products shown before click)
        cascade = GET_PRODUCTS_AT_POSITIONS(1 to click_position IN ranking[u])
        
        // Step 3: Process each product in cascade
        FOR each product i in cascade:
            
            // Step 3a: Assign reward
            IF i == clicked_product THEN
                reward = 1
            ELSE
                reward = 0
            END IF
            
            // Step 3b: Get context vector
            x_ui = CONCATENATE(user_features[u], product_features[i])
            
            // Step 3c: Update matrices
            A_i_new = A_i + x_ui Ã— x_ui^T  // Outer product
            b_i_new = b_i + reward Ã— x_ui
            
            // Step 3d: Store updates
            A_updates[i].APPEND(A_i_new)
            b_updates[i].APPEND(b_i_new)
            
        END FOR
        
    END FOR
    
    // Step 4: Aggregate updates per product
    FOR each product i with updates:
        
        // Take final cumulative update
        A_i_final = LAST(A_updates[i])
        b_i_final = LAST(b_updates[i])
        
        // Persist updates
        UPDATE product_matrices_table 
        SET A_i = A_i_final, b_i = b_i_final
        WHERE product_id = i
        
    END FOR
    
    RETURN update_statistics

END FUNCTION
MAIN EXECUTION LOOP

Example
FUNCTION Main():
    
    // ========================================
    // INITIALIZATION
    // ========================================
    
    LOAD user_features FROM database
    LOAD product_features FROM database
    LOAD product_matrices (A_i, b_i) FROM database
    LOAD current_rankings FROM database
    LOAD click_events FROM database
    
    LOG "Starting Cascading Bandits System"
    LOG "Users: {count(users)}, Products: {count(products)}"
    
    // ========================================
    // PHASE 1: PREDICTION (RE-RANKING)
    // ========================================
    
    LOG "Phase 1: Re-ranking products using LinUCB"
    
    new_rankings = ReRankProducts()
    
    LOG "Re-ranking complete for {count(users)} users"
    LOG "Average ranking changes: {calculate_avg_change()}"
    
    // ========================================
    // PHASE 2: UPDATE (LEARNING)
    // ========================================
    
    LOG "Phase 2: Learning from user clicks"
    
    update_stats = LearnFromClicks()
    
    LOG "Learning complete"
    LOG "Products updated: {update_stats.products_updated}"
    LOG "Total interactions: {update_stats.total_interactions}"
    LOG "Positive rewards: {update_stats.positive_rewards}"
    
    // ========================================
    // VALIDATION & METRICS
    // ========================================
    
    LOG "Phase 3: Validation and metrics"
    
    metrics = CalculateMetrics()
    
    LOG "Average clicked product position: {metrics.avg_click_position}"
    LOG "Click-through rate: {metrics.ctr}%"
    LOG "Products with improved rankings: {metrics.improved_products}"
    
    LOG "System update completed successfully"
    
END FUNCTION
HELPER FUNCTIONS

Example
FUNCTION CalculateMetrics():
    
    // Click-through rate
    ctr = (total_clicks / total_impressions) Ã— 100
    
    // Average position of clicked products
    avg_click_position = MEAN(position of clicked products)
    
    // Ranking improvement
    FOR each clicked product:
        old_position = original_ranking[product]
        new_position = updated_ranking[product]
        improvement = old_position - new_position
    END FOR
    avg_improvement = MEAN(improvement)
    
    RETURN {ctr, avg_click_position, avg_improvement}
    
END FUNCTION


FUNCTION FIND_POSITION(product IN ranking):
    
    FOR position = 1 TO LENGTH(ranking):
        IF ranking[position] == product THEN
            RETURN position
        END IF
    END FOR
    
    RETURN -1 // Not found
    
END FUNCTION


FUNCTION GET_PRODUCTS_AT_POSITIONS(start TO end IN ranking):
    
    cascade = []
    
    FOR position = start TO end:
        cascade.APPEND(ranking[position])
    END FOR
    
    RETURN cascade
    
END FUNCTION
DATA STRUCTURES

Example
USER_FEATURES:
    - customerId: string
    - norm_offline_transactions: float [0, 1]
    - norm_offline_atv: float [0, 1]
    - norm_online_transactions: float [0, 1]
    - norm_online_atv: float [0, 1]

PRODUCT_FEATURES:
    - productCode: string
    - norm_global_popularity: float [0, 1]
    - norm_co_occurrence: float [0, 1]

PRODUCT_MATRICES:
    - productCode: string
    - A_i: matrix[6Ã—6] of floats
    - b_i: vector[6] of floats

USER_RANKINGS:
    - customerId: string
    - product_rankings: map<int, string>
      // Key: position (1, 2, 3, ...)
      // Value: productCode

CLICK_EVENTS:
    - customerId: string
    - productCode: string
    - click_sequence: int
MATHEMATICAL FORMULAS

Example
CONTEXT VECTOR:
    x_ui âˆˆ â„^6 = [user_features (4D), product_features (2D)]

PARAMETER ESTIMATION:
    Î¸_i = A_i^(-1) Ã— b_i
    where:
        A_i âˆˆ â„^(6Ã—6) - covariance matrix
        b_i âˆˆ â„^6 - reward-weighted feature sum

UCB SCORE:
    UCB_i(x_ui) = Î¸_i^T Ã— x_ui + Î± Ã— sqrt(x_ui^T Ã— A_i^(-1) Ã— x_ui)
    where:
        Î¸_i^T Ã— x_ui - exploitation term (expected reward)
        Î± Ã— sqrt(...) - exploration term (uncertainty)

MATRIX UPDATES:
    A_i â† A_i + x_ui Ã— x_ui^T
    b_i â† b_i + r_ui Ã— x_ui
    where:
        r_ui âˆˆ {0, 1} - observed reward (click or no click)

CASCADE MODEL:
    For click at position k:
        Update all products at positions 1, 2, ..., k
        Reward = 1 for clicked product (position k)
        Reward = 0 for products at positions 1, ..., k-1
ALGORITHM PROPERTIES

Example
TIME COMPLEXITY:
    - Prediction (per user): O(n Ã— d^3)
      where n = products per user, d = feature dimension
    
    - Update (per click): O(k Ã— d^2)
      where k = click position (cascade depth)

SPACE COMPLEXITY:
    - Per product: O(d^2) for A_i matrix
    - Total: O(m Ã— d^2)
      where m = total products

CONVERGENCE:
    - Regret bound: O(âˆšT) with high probability
    - T = number of rounds (clicks)

KEY PROPERTIES:
    1. Exploration-Exploitation Trade-off: Controlled by Î±
    2. Position Bias Handling: Via cascade model
    3. Personalization: Via user-specific features
    4. Online Learning: Updates after each interaction
WORKFLOW DIAGRAM

Example
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CASCADING BANDITS SYSTEM                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Initialize  â”‚
    â”‚  A_i = I     â”‚
    â”‚  b_i = 0     â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PHASE 1: PREDICTION (RE-RANKING)    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  For each user-product pair:         â”‚
    â”‚    1. Combine features â†’ x_ui        â”‚
    â”‚    2. Calculate Î¸_i = A_i^(-1) b_i   â”‚
    â”‚    3. Calculate UCB score            â”‚
    â”‚    4. Rank by UCB (descending)       â”‚
    â”‚  Update rankings in database         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        User sees ranked list          â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚        User clicks product            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  PHASE 2: UPDATE (LEARNING)          â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  For each click:                     â”‚
    â”‚    1. Get click position k           â”‚
    â”‚    2. Get cascade (positions 1..k)   â”‚
    â”‚    3. Assign rewards:                â”‚
    â”‚       - Clicked product: r = 1       â”‚
    â”‚       - Others in cascade: r = 0     â”‚
    â”‚    4. Update matrices:               â”‚
    â”‚       A_i â† A_i + x Ã— x^T            â”‚
    â”‚       b_i â† b_i + r Ã— x              â”‚
    â”‚  Persist updates to database         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         Calculate Metrics             â”‚
    â”‚  - CTR, Avg Position, Improvements   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â–¼
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚  Loop Back    â”‚
           â”‚  (Next Round) â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
KEY INSIGHTS

Example
1. EXPLORATION vs EXPLOITATION:
   - High Î± â†’ More exploration (try uncertain products)
   - Low Î± â†’ More exploitation (stick with known winners)

2. CASCADE MODEL:
   - Accounts for position bias
   - Products higher in list get more "credit" for non-clicks
   - Clicked product gets positive reward
   - Skipped products get negative signal

3. PERSONALIZATION:
   - User features capture individual preferences
   - Product features capture item characteristics
   - Combination allows personalized recommendations

4. ONLINE LEARNING:
   - System improves continuously with each interaction
   - No need for batch retraining
   - Adapts to changing user preferences

5. SCALABILITY:
   - Matrix operations parallelizable
   - Updates can be batched
   - Incremental learning reduces computation
This pseudocode provides a complete, implementation-ready blueprint for the Cascading Bandits system! ğŸš€
